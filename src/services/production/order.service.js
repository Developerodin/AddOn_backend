import httpStatus from 'http-status';
import mongoose from 'mongoose';
import { ProductionOrder, Article, ArticleLog } from '../../models/production/index.js';
import ApiError from '../../utils/ApiError.js';
import { generateArticleNumber } from '../../utils/generateId.js';
import { getAllFloorsOrder, getFloorKey } from '../../utils/productionHelper.js';
// import { generateOrderNumber } from '../../utils/generateId.js'; // Using model's auto-generation instead

/**
 * Create a production order
 * @param {Object} orderBody
 * @param {Object} user - Current user from request
 * @returns {Promise<ProductionOrder>}
 */
export const createProductionOrder = async (orderBody, user = null) => {
  // Set user fields if not provided
  if (!orderBody.createdBy && user) {
    orderBody.createdBy = user.id;
  }
  if (!orderBody.lastModifiedBy && user) {
    orderBody.lastModifiedBy = user.id;
  }

  // Order number will be auto-generated by the model's pre-save middleware
  // Remove orderNumber from orderBody to let the model handle it
  delete orderBody.orderNumber;

  // Create articles with initial logs
  const articles = [];
  for (const articleData of orderBody.articles) {
    const article = new Article({
      ...articleData,
      id: await generateArticleNumber(), // Generate unique article ID
      currentFloor: 'Knitting',
      status: 'Pending',
      progress: 0,
      completedQuantity: 0,
      logs: []
    });
    articles.push(article);
  }

  // Create the order
  const order = new ProductionOrder({
    ...orderBody,
    articles: [],
    currentFloor: 'Knitting',
    status: 'Pending'
  });

  // Save order first to get ID
  await order.save();

  // Update articles with order ID and save them
  for (let i = 0; i < articles.length; i++) {
    articles[i].orderId = order._id;
    await articles[i].save();
  }

  // Update order with article IDs
  order.articles = articles.map(article => article._id);
  await order.save();

  // Create initial logs for each article
  for (const article of articles) {
    await createArticleLog({
      articleId: article._id.toString(),
      orderId: order._id.toString(),
      action: 'Article Added',
      quantity: article.plannedQuantity,
      remarks: `Article ${article.articleNumber} added to order ${order.orderNumber}`,
      userId: orderBody.createdBy || user?.id || 'system',
      floorSupervisorId: orderBody.createdBy || user?.id || 'system'
    });
  }

  // Create order creation log
  await createArticleLog({
    orderId: order._id.toString(),
    action: 'Order Created',
    quantity: 0,
    remarks: `Order ${order.orderNumber} created with ${articles.length} articles`,
    userId: orderBody.createdBy || user?.id || 'system',
    floorSupervisorId: orderBody.createdBy || user?.id || 'system'
  });

  return order.populate('articles');
};

/**
 * Query for production orders
 * @param {Object} filter - Mongo filter
 * @param {Object} options - Query options
 * @returns {Promise<QueryResult>}
 */
export const queryProductionOrders = async (filter, options) => {
  const orders = await ProductionOrder.paginate(filter, {
    ...options,
    populate: 'articles'
  });
  return orders;
};

/**
 * Get production order by id
 * @param {ObjectId} id
 * @returns {Promise<ProductionOrder>}
 */
export const getProductionOrderById = async (id) => {
  return ProductionOrder.findById(id)
    .populate('articles')
    .populate('createdBy', 'name email')
    .populate('lastModifiedBy', 'name email');
};

/**
 * Update production order by id
 * @param {ObjectId} orderId
 * @param {Object} updateBody
 * @returns {Promise<ProductionOrder>}
 */
export const updateProductionOrderById = async (orderId, updateBody) => {
  const order = await getProductionOrderById(orderId);
  if (!order) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Production order not found');
  }

  // Check if order number is being changed and if it's unique
  if (updateBody.orderNumber && updateBody.orderNumber !== order.orderNumber) {
    if (await ProductionOrder.findOne({ orderNumber: updateBody.orderNumber, _id: { $ne: orderId } })) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'Order number already taken');
    }
  }

  // Store previous values for logging
  const previousValues = {
    priority: order.priority,
    status: order.status,
    orderNote: order.orderNote,
    articles: order.articles.map(article => article._id || article)
  };

  // Handle articles update separately
  if (updateBody.articles && Array.isArray(updateBody.articles)) {
    // If articles are provided as objects with IDs, we need to find the actual Article documents
    const articleIds = [];
    
    for (const article of updateBody.articles) {
      let articleId = null;
      
      if (typeof article === 'string') {
        articleId = article;
      } else if (article && article.id) {
        articleId = article.id;
      } else if (article && article._id) {
        articleId = article._id;
      }
      
      if (articleId) {
        // Check if it's a valid MongoDB ObjectId (24 hex characters)
        if (mongoose.Types.ObjectId.isValid(articleId) && articleId.length === 24) {
          articleIds.push(new mongoose.Types.ObjectId(articleId));
        } else {
          // If it's a custom ID (like ARTMFDVOOJCLKC), find the article by its custom id field
          const articleDoc = await Article.findOne({ id: articleId });
          if (articleDoc) {
            articleIds.push(articleDoc._id);
          } else {
            console.warn(`Article with custom ID ${articleId} not found`);
          }
        }
      }
    }
    
    updateBody.articles = articleIds;
  }

  // Update other fields
  const fieldsToUpdate = { ...updateBody };
  delete fieldsToUpdate.articles; // Handle articles separately

  Object.assign(order, fieldsToUpdate);
  
  // Update articles if provided
  if (updateBody.articles) {
    order.articles = updateBody.articles;
  }

  await order.save();

  // Create update log
  await createArticleLog({
    orderId: order._id.toString(),
    action: 'Order Updated',
    quantity: 0,
    remarks: `Order ${order.orderNumber} updated`,
    previousValue: JSON.stringify(previousValues),
    newValue: JSON.stringify(updateBody),
    changeReason: 'Order modification',
    userId: updateBody.lastModifiedBy || order.lastModifiedBy || 'system',
    floorSupervisorId: updateBody.lastModifiedBy || order.lastModifiedBy || 'system'
  });

  return order;
};

/**
 * Delete production order by id
 * @param {ObjectId} orderId
 * @returns {Promise<ProductionOrder>}
 */
export const deleteProductionOrderById = async (orderId) => {
  const order = await getProductionOrderById(orderId);
  if (!order) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Production order not found');
  }

  // Allow deletion of orders regardless of status

  // Delete all articles and their logs
  for (const article of order.articles) {
    const articleId = article._id || article; // Handle both populated and non-populated articles
    await ArticleLog.deleteMany({ articleId: articleId.toString() });
    await Article.findByIdAndDelete(articleId);
  }

  // Delete order logs
  await ArticleLog.deleteMany({ orderId: orderId.toString() });

  // Delete the order
  await order.deleteOne();

  return order;
};

/**
 * Get orders by floor
 * @param {string} floor
 * @param {Object} filter
 * @param {Object} options
 * @returns {Promise<QueryResult>}
 */
export const getOrdersByFloor = async (floor, filter, options) => {
  // Use comprehensive floor order for visibility logic
  const floorOrder = getAllFloorsOrder();

  // Map URL-friendly floor names to proper enum values
  const floorMapping = {
    'FinalChecking': 'Final Checking',
    'FinalChecking': 'Final Checking',
    'finalchecking': 'Final Checking',
    'final-checking': 'Final Checking',
    'final_checking': 'Final Checking'
  };

  // Convert floor name if needed
  const normalizedFloor = floorMapping[floor] || floor;

  const requestedFloorIndex = floorOrder.indexOf(normalizedFloor);
  if (requestedFloorIndex === -1) {
    throw new ApiError(httpStatus.BAD_REQUEST, `Invalid floor: ${floor}`);
  }

  // Build complex query for floor visibility
  const floorKey = getFloorKey(normalizedFloor);
  const floorFilter = {
    ...filter,
    $or: [
      // 1. Orders currently on this floor
      { currentFloor: normalizedFloor },
      // 2. Orders on previous floors (if entire order not completed)
      {
        currentFloor: { $in: floorOrder.slice(0, requestedFloorIndex) },
        status: { $ne: 'Completed' }
      },
      // 3. Orders that have work on this floor (received quantity > 0)
      {
        [`articles.floorQuantities.${floorKey}.received`]: { $gt: 0 }
      }
    ]
  };

  // Get orders with basic populate first
  const orders = await ProductionOrder.paginate(floorFilter, {
    ...options,
    populate: 'articles'
  });

  // Post-process to filter out orders and articles that shouldn't be visible on this floor
  const filteredResults = orders.results.filter(order => {
    // Check if order should be visible on this floor
    if (!shouldOrderBeVisibleOnFloor(order, normalizedFloor, floorOrder)) {
      return false;
    }
    
    // Filter articles within the order
    if (order.articles && order.articles.length > 0) {
      order.articles = order.articles.filter(article => {
        return shouldArticleBeVisibleOnFloor(article, normalizedFloor, floorOrder);
      });
    }
    
    return true;
  });

  return {
    ...orders,
    results: filteredResults,
    totalResults: filteredResults.length,
    totalPages: Math.ceil(filteredResults.length / (options.limit || 10))
  };
};

/**
 * Check if an order should be visible on a specific floor
 * @param {Object} order - Production order
 * @param {string} floor - Requested floor
 * @param {Array} floorOrder - Array of floors in order
 * @returns {boolean}
 */
const shouldOrderBeVisibleOnFloor = (order, floor, floorOrder) => {
  const requestedFloorIndex = floorOrder.indexOf(floor);
  const currentFloorIndex = floorOrder.indexOf(order.currentFloor);

  // 1. Always show if order is currently on this floor
  if (order.currentFloor === floor) {
    return true;
  }

  // 2. Show if order is on a previous floor and not completed
  if (currentFloorIndex < requestedFloorIndex && order.status !== 'Completed') {
    return true;
  }

  // 3. Show if any article has work on this floor
  if (order.articles && order.articles.length > 0) {
    const floorKey = getFloorKey(floor);
    
    for (const article of order.articles) {
      const floorData = article.floorQuantities[floorKey];
      if (floorData && floorData.received > 0) {
        return true;
      }
    }
  }

  return false;
};

/**
 * Check if an article should be visible on a specific floor
 * @param {Object} article - Article object
 * @param {string} floor - Requested floor
 * @param {Array} floorOrder - Array of floors in order
 * @returns {boolean}
 */
const shouldArticleBeVisibleOnFloor = (article, floor, floorOrder) => {
  const requestedFloorIndex = floorOrder.indexOf(floor);
  const currentFloorIndex = floorOrder.indexOf(article.currentFloor);

  // 1. Always show if article is currently on this floor
  if (article.currentFloor === floor) {
    return true;
  }

  // 2. Show if article is on a previous floor and not completed
  if (currentFloorIndex < requestedFloorIndex && article.status !== 'Completed') {
    return true;
  }

  // 3. Show if article has work on this floor
  const floorKey = getFloorKey(floor);
  const floorData = article.floorQuantities[floorKey];
  if (floorData && floorData.received > 0) {
    return true;
  }

  return false;
};

// getFloorKey function is now imported from productionHelper.js

/**
 * Bulk create orders
 * @param {Array} orders - Array of order objects
 * @param {number} batchSize - Number of orders to process in each batch
 * @param {Object} user - Current user from request
 * @returns {Promise<Object>}
 */
export const bulkCreateOrders = async (orders, batchSize = 50, user = null) => {
  const results = {
    total: orders.length,
    created: 0,
    failed: 0,
    errors: [],
    processingTime: 0,
  };

  const startTime = Date.now();

  try {
    // Process orders in batches
    for (let i = 0; i < orders.length; i += batchSize) {
      const batch = orders.slice(i, i + batchSize);
      
      const batchPromises = batch.map(async (orderData, batchIndex) => {
        const globalIndex = i + batchIndex;
        
        try {
          // Order number will be auto-generated by the model
          // Remove orderNumber from orderData to let the model handle it
          delete orderData.orderNumber;

          // Create the order
          const order = await createProductionOrder(orderData, user);
          results.created++;
          
        } catch (error) {
          results.failed++;
          results.errors.push({
            index: globalIndex,
            orderNumber: orderData.orderNumber || `Order ${globalIndex + 1}`,
            error: error.message,
          });
        }
      });

      await Promise.all(batchPromises);
      
      // Add delay between batches
      if (i + batchSize < orders.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    results.processingTime = Date.now() - startTime;
    console.log(`Bulk order creation completed in ${results.processingTime}ms: ${results.created} created, ${results.failed} failed`);

  } catch (error) {
    results.processingTime = Date.now() - startTime;
    throw new ApiError(httpStatus.BAD_REQUEST, error.message);
  }

  return results;
};

/**
 * Create article log helper function
 * @param {Object} logData
 * @returns {Promise<ArticleLog>}
 */
const createArticleLog = async (logData) => {
  const log = new ArticleLog({
    id: `LOG-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    ...logData,
    date: new Date().toISOString().split('T')[0],
    timestamp: new Date().toISOString()
  });
  
  return log.save();
};
